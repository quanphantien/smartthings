"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignatureVerifier = exports.HttpKeyResolver = void 0;
const axios_1 = __importDefault(require("axios"));
const sshpk_1 = __importDefault(require("sshpk"));
const http_signature_1 = __importDefault(require("http-signature"));
const endpoint_client_1 = require("./endpoint-client");
class HttpKeyResolver {
    constructor(config) {
        this.keyApiUrl = endpoint_client_1.defaultSmartThingsURLProvider.keyApiURL;
        this.keyCache = undefined;
        this.keyCacheTTL = (24 * 60 * 60 * 1000);
        if (config) {
            if (config.urlProvider) {
                this.keyApiUrl = config.urlProvider.keyApiURL;
            }
            if (config.keyCacheTTL) {
                this.keyCacheTTL = config.keyCacheTTL || (24 * 60 * 60 * 1000);
            }
            this.keyCache = config.keyCache;
        }
    }
    /**
     * Get Public Key for specified Key ID.
     *
     * @param {String} keyId The Key ID as specified on Authorization header.
     * @returns {Promise.<Object>} Promise of Public key or null if no key available.
     */
    async getKey(keyId) {
        const cache = this.keyCache;
        if (!keyId) {
            return null;
        }
        let publicKey = cache ? cache.get(keyId) : undefined;
        if (publicKey) {
            return publicKey;
        }
        const response = await axios_1.default.get(`${this.keyApiUrl}${keyId}`);
        const cert = sshpk_1.default.parseCertificate(response.data, 'pem');
        if (cert && cert.subjectKey) {
            publicKey = cert.subjectKey;
        }
        if (publicKey) {
            if (cache) {
                cache.set(keyId, publicKey, this.keyCacheTTL);
            }
            return publicKey;
        }
        return null;
    }
}
exports.HttpKeyResolver = HttpKeyResolver;
class SignatureVerifier {
    constructor(keyResolver, logger) {
        this.keyResolver = keyResolver;
        this.logger = logger;
    }
    async isAuthorized(request) {
        try {
            const keyResolver = this.keyResolver;
            const parsed = http_signature_1.default.parseRequest(request, undefined);
            const publicKey = await keyResolver.getKey(parsed.keyId);
            return http_signature_1.default.verifySignature(parsed, publicKey);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            if (this.logger) {
                this.logger.error(error.message | error);
            }
        }
        return false;
    }
}
exports.SignatureVerifier = SignatureVerifier;
